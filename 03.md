### TDD Study - 02. 모두를 위한 평등

어떤 정수에 1을 더했을 때 원래 정수에 1이 더해진 새로운 값을 갖게될 것을 예상한다
하지만 객체는 1을 더하면 해당 정수 자체가 변하게 된다.

`Dollar` 객체같이 객체를 값처럼 쓰는 것을 **값 객체 패턴(value object pattern)** 이라고 한다

- 값 객체에 대한 제약사항 중 하나는 객체의 인스턴스 변수가 생성자를 통해서 일단 설정된 후에는 결코 변하지 않는다.

- 값 객체를 사용하면 별칭 문제에 대해 걱정할 필요가 없다
  - 두번째 값을 변경했을 때 첫번 째 값까지 변화되는 문제를 해결할 수 있음

- $5로 생성했다면, 영원히 $5임을 보장받을 수 있다

Todo List

1. $5 + 10CHF $10 (환율이 2:1일 경우)  
2. ~~$5 * 2 = $10~~
3. amount를 private으로 만들기
4. ~~Dollar 부작용(side effect)~~
5. Money 반올림?
6. **equals()**

---

### 1. 실패하는 테스트 코드 작성하기
**생성한 객체가 $5 인지 확인해보자**
```
func testEquality() {
    XCTAssertTrue(Dollar(amount: 5).equals(Dollar(amount: 5)))
}
```

02 타락한 객체 편에서 봤던 [빨리 성공하는 코드를 작성하기 위해 할 수 있는 전략](02.md) 으로 *가짜로 구현하는 방법* 을 선택해본다  
단순히 true를 반환하는 `equals()` 를 만든다

### 2. 테스트가 통과하게 끔 만들기
```
func equals(any: Any) -> Bool {
    return true
}
```

---

### 삼각측량
```
라디오 신호를 두 수신국이 감지하고 있을 때, 수신국 사이의 거리가 알려져 있고
각 수신국이 신호의 방향을 알고 있다면, 이 정보들만으로 충분히 신호의 거리와 방위를 알 수 있다.
```

삼각측량을 이용하려면 예제가 두 개 이상 있어야만 코드를 일반화할 수 있다.  
테스트를 한 개 추가한다  
`XCTAssertFalse(Dollar(amount: 5).equals(Dollar(amount: 6)))`

### 3. 동치성(equality) 일반화 하기
```
func equals(_ any: Any) -> Bool {
    let dollar = any as! Dollar
    return amount == dollar.amount
}
```

동시성 문제는 일시적으로 해결되었지만, 널 값이나 다른 객체들과 비교한다면?
지금 당장은 필요하지 않으므로 할일 목록에만 추가

이제 동질성 기능을 구현했으므로 `Dollar` 와 `Dollar` 를 직접 비교할 수 있게 되었다


---

### 정리
- 디자인 패턴 (값 객체)이 하나의 또 다른 오퍼레이션을 암시한다는 것을 알게 됌
- 해당 오퍼레이션 테스트
- 해당 오퍼레이션 간단히 구현
- 리팩토링대신 테스트 더 진행
- 두 경우를 모두 수용할 수 있도록 리팩토링
