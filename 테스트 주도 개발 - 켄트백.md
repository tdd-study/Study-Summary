## 테스트 주도 개발 - 켄트백



### 1장. 다중 통화를 지원하는 Money 객체

---

**의존성과 중복**

테스트와 코드 간의 문제는 중복이 아니다. 의존성이다. 

의존성이 문제 그 자체라면 중복은 문제의 징후다. 하지만 중복 제거만으로도 문제 자체, 즉 의존성을 해결할 수 있다. 



TDD의 핵심은 작은 단계를 밟을 능력을 갖추어야 한다는 것이다.



### 2장. 타락한 객체

---

**초록색(테스트 성공)**을 빨리 보기 위한 전략.

1. 가짜로 구현하기 - 상수를 반환하게 만들고 진짜 코드를 얻을 때까지 단계적으로 상수를 변수로 바꾸어 간다.
2. 명박한 구현 사용하기
3. 삼각측량



지금까지 배운 것.

- 설계상의 결함을 그 결함으로 인해 실패하는 테스트로 변환했다. 
- 스텁(가짜) 구현으로 빠르게 컴파일을 통과하도록 만들었다. 
- 올바르다고 생각하는 코드를 입력하여 테스트를 통과했다. 



### 3장. 모두를 위한 평등

---

객체를 값처럼 사용하는 것을 **값 객체 패턴(Value object pattern)**이라 한다. 값 객체에 대해 제약사항 중 하나는 객체의 인스턴스 변수가 생성자를 통해서 일단 설정된 후에는 결코 변하지 않는다는 것. 

**동치성**

⁉️*여기서 말하는 삼각측량이란?*



지금까지 배운 것.

- 우리의 디자인 패턴이 하나의 또 다른 오퍼레이션을 암시한다는 것을 알아챘다.
- 해당 오퍼레이션을 테스트했다. 
- 해당 오퍼레이션을 간단히 구현했다. 
- 곧장 리팩토링하는 대신 테스트를 조금 더 했다. 
- 두 경우를 모두 수용할 수 있도록 리팩토링했다.



### 4장. 프라이버시

---

동치성 테스트가 동치성에 대한 코드가 정확히 작동한다는 것을 검증하는데 실패한다면, 곱하기 테스트 역시 곱하기에 대한 코드가 정확하게 작동한다는 것을 검증하는 데 실패하게 된다.

(*같다는 걸 검증하는 로직이 틀렸다면? 을 말하는 것인가?*)



지금까지 배운 것.

- 오직 테스트를 향상시키기 위해서만 개발된 기능을 사용했다. 
- 두 테스트가 동시에 실패하면 망한다는 점을 인식했다.⁉️
- 위험 요소가 있음에도 계속 진행했다. 
- 테스트와 코드 사이의 결합도를 낮추기 위해, 테스트하는 객체의 새 기능을 사용했다.



### 5장. 솔직히 말하자면

---

테스트 주기

1. 테스트 작성
2. 컴파일되게 하기
3. 실패하는지 확인하기 위해 실행
4. 실행하게 만듦
5. 중복 제거 

처음 네 단계는 빠르게 진행해야 한다. 어떤 죄(중복)든 저지를 수 있다.



지금까지 배운 것.

- 큰 테스트를 공략할 수 없다. 그래서 진전을 나타낼 수 있는지 자그마한 테스트를 만들었다.
- 뻔뻔스럽게도 중복을 만들고 조금 고쳐서 테스트를 작성했다. 
- 설상가상으로 모델 코드까지 도매금으로 복사하고 수정해서 테스트를 통과했다. 
- 중복이 사라지기 전에는 집에 가지 않겠다고 약속했다.



### 6장. 돌아온 '모두를 위한 평등'

---

5장에서 새로운 테스트 케이스를 추가했다. 하지만 테스트를 빨리 통과하기 위해 몇 톤이나 되는 코드를 복사해서 붙이는 엄청난 죄를 저질렀다. 

`Dollar`와 `Franc` 클래스는 `Money` 클래스를 상속받도록 하여 중복 코드를 최소화했다. 

충분한 테스트가 없다면 지원 테스트가 갖춰지지 않는 리팩토링을 만날 수 밖에 없다. 

있으면 좋을 것 같은 테스트를 작성하라. 그렇게 하지 않으면 결국에는 리팩토링하다가 뭔가 깨뜨릴 것이다. 



지금까지 배운 것.

- 공통된 코드를 첫 번째 클래스에서 상위 클래스로 단계적으로 옮겼다. 
- 두 번째 클래스(`Franc`)도 `Money`의 하위 클래스로 만들었다. 
- 불필요한 구현을 제거하기 전에 두 `equal` 구현을 일치시켰다. 



지금까지의 코드 

```swift
class Money {
  fileprivate var amount: Int

  init(_ amount: Int) {
    self.amount = amount
  }
}

extension Money: Equatable {
  static func == (lhs: Money, rhs: Money) -> Bool {
    return lhs.amount == rhs.amount
  }
  
  func equals(_ money: Money) -> Bool {
    return amount == money.amount
  }
}

class Dollar: Money {
  func times(_ multiplier: Int) -> Dollar {
    return Dollar(amount * multiplier)
  }
}

class Franc: Money {
  func times(_ multiplier: Int) -> Franc {
    return Franc(amount * multiplier)
  }
}

class TDD_PracticeTests: XCTestCase {

  func testMultiplication() {
    let five: Dollar = Dollar(5)
    XCTAssertEqual(Dollar(10), five.times(2))
    XCTAssertEqual(Dollar(15), five.times(3))
  }

  func testEquality() {
    XCTAssertTrue(Dollar(5).equals(Dollar(5)))
    XCTAssertFalse(Dollar(5).equals(Dollar(6)))
  }

  func testFrancMultiplication() {
    let five: Franc = Franc(5)
    XCTAssertEqual(Franc(10), five.times(2))
    XCTAssertEqual(Franc(15), five.times(3))
  }
}
```



### 7장 사과와 오렌지

---

`Franc`과 `Dollar`를 비교하면 어떻게 될까? 

```swift
func equals(_ money: Money) -> Bool {
  return amount == money.amount && String(describing: self) == String(describing: money)
}
```

현재는 `Franc`과 `Dollar`의 `amount`가 같다면 동일한 것으로 처리된다. 그러므로 **일단은** 타입 검사로 둘을 구분하였다.

현재는 통화(currency) 개념은 없다. 이젠 `times()` 코드를 처리해야 한다. 혼합된 통화간의 연산에 대해 다루어야 한다. 



지금까지 배운 것

- 우릴 괴롭히던 결함을 끄집어내서 테스트에 담아냈다.

- 완벽하진 않지만 그럭저럭 봐줄 만한 방법으로 테스트를 통과하게 만들었다 (`String(describing: self)`)



지금까지의 코드

```swift
class Money {
  fileprivate var amount: Int

  init(_ amount: Int) {
    self.amount = amount
  }
}

extension Money: Equatable {
  static func == (lhs: Money, rhs: Money) -> Bool {
    return lhs.amount == rhs.amount
  }

  func equals(_ money: Money) -> Bool {
    return amount == money.amount && String(describing: self) == String(describing: money)
  }
}

class Dollar: Money {
  func times(_ multiplier: Int) -> Dollar {
    return Dollar(amount * multiplier)
  }
}

class Franc: Money {
  func times(_ multiplier: Int) -> Franc {
    return Franc(amount * multiplier)
  }
}

class TDD_PracticeTests: XCTestCase {

  func testMultiplication() {
    let five: Dollar = Dollar(5)
    XCTAssertEqual(Dollar(10), five.times(2))
    XCTAssertEqual(Dollar(15), five.times(3))
  }

  func testEquality() {
    XCTAssertTrue(Dollar(5).equals(Dollar(5)))
    XCTAssertFalse(Dollar(5).equals(Dollar(6)))
    XCTAssertTrue(Dollar(5).equals(Franc(5)))
  }

  func testFrancMultiplication() {
    let five: Franc = Franc(5)
    XCTAssertEqual(Franc(10), five.times(2))
    XCTAssertEqual(Franc(15), five.times(3))
  }
}
```



### 8장 객체 만들기

---

하위 클래스에 대한 직접적인 참조가 적어진다면 하위 클래스를 제거하기 위해 한 발짝 더 다가섰다고 할 수 있겠다.

`Dollar`를 반환하는 팩토리 메소드를 `Money` 내에 위치시키자. 

 ```swift
class Money {
  fileprivate var amount: Int

  init(_ amount: Int) {
    self.amount = amount
  }

  static func dollar(_ amount: Int) -> Money {
    return Dollar(amount)
  }
}
 ```

테스트 코드에서도 `Dollar`에 대한 참조를 제거할 수 있다. 

```swift
func testMultiplication() {
  let five: Money = Money.dollar(5)
  XCTAssertEqual(Money.dollar(10), five.times(2))
  XCTAssertEqual(Money.dollar(15), five.times(3))
}
```

`Franc`도 동일하게 구현해준다. 

`times` 메소드도 `Money`내에 위치시키자.

>  추상 클래스를 구현하기 위해 이를 프로토콜로 구현했다. 

```swift
protocol MoneyType {
  func times(_ multiplier: Int) -> Money
}

class Money: MoneyType {
  fileprivate var amount: Int

  init(_ amount: Int) {
    self.amount = amount
  }

  static func dollar(_ amount: Int) -> Money {
    return Dollar(amount)
  }

  static func franc(_ amount: Int) -> Money {
    return Franc(amount)
  }

  func times(_ multiplier: Int) -> Money {
    return Money(amount * multiplier)
  }
}

extension Money: Equatable {
  static func == (lhs: Money, rhs: Money) -> Bool {
    return lhs.amount == rhs.amount
  }

  func equals(_ money: Money) -> Bool {
    return amount == money.amount && String(describing: self) == String(describing: money)
  }
}

class Dollar: Money {
  override func times(_ multiplier: Int) -> Money {
    return Dollar(amount * multiplier)
  }
}

class Franc: Money {
  override func times(_ multiplier: Int) -> Money {
    return Franc(amount * multiplier)
  }
}

class TDD_PracticeTests: XCTestCase {

  func testMultiplication() {
    let five: Money = Money.dollar(5)
    XCTAssertEqual(Money.dollar(10), five.times(2))
    XCTAssertEqual(Money.dollar(15), five.times(3))
  }

  func testEquality() {
    XCTAssertTrue(Money.dollar(5).equals(Money.dollar(5)))
    XCTAssertFalse(Money.dollar(5).equals(Money.dollar(6)))
    XCTAssertTrue(Money.franc(5).equals(Money.franc(5)))
    XCTAssertFalse(Money.franc(5).equals(Money.franc(6)))
    XCTAssertFalse(Money.franc(5).equals(Money.dollar(5)))
  }

  func testFrancMultiplication() {
    let five: Money = Money.franc(5)
    XCTAssertEqual(Money.franc(10), five.times(2))
    XCTAssertEqual(Money.franc(15), five.times(3))
  }
}
```



### 9장 우리가 사는 시간

---

> 8장까지 Java 코드를 Swift로 전환하면서 저자의 의도를 간직하며 코드를 전환하고 있는지에 대한 의문이 들었다. 그리하여 8장까지 Swift로 전환된 코드를 가져와 9장부터 진행해보려 한다. 

이제 통화 개념을 도입하려 한다. 

통화를 나타내는 문자열을 정적 팩토리 메소드로 옮긴다. 이를 생성자를 통해 구현했다. 

```swift
class Money: Equatable {
    fileprivate var amount: Int
    public var currency: String
    
    init(_ amount: Int, currency: String) {
        self.amount = amount
        self.currency = currency
    }
    
    func times(_ by: Int) -> Money {
        fatalError("Must Override")
    }
}

extension Money {
    static func dollar(_ amount: Int) -> Money {
        return Dollar(amount, currency: "USD")
    }
    
    static func franc(_ amount: Int) -> Money {
        return Franc(amount, currency: "CHF")
    }
}

func == <T: Money>(lhs: T, rhs: T) -> Bool {
    return lhs.amount == rhs.amount
        && String(describing: lhs.self) == String(describing: rhs.self)
}

class Dollar: Money {
    override func times(_ by: Int) -> Money {
        return Money.dollar(self.amount * by)
    }
}

class Franc: Money {
    override func times(_ by: Int) -> Money {
        return Money.franc(self.amount * by)
    }
}

class DollarTests: XCTestCase {
    func testMultiplication() {
        let five = Money.dollar(5)
        XCTAssertEqual(Money.dollar(5 * 2), five.times(2))
        XCTAssertEqual(Money.dollar(5 * 3), five.times(3))
    }
    
    func testFrancMultiplication() {
        let five = Money.franc(5)
        XCTAssertEqual(Money.franc(5 * 2), five.times(2))
        XCTAssertEqual(Money.franc(5 * 3), five.times(3))
    }
    
    func testEquality() {
        XCTAssertEqual(Money.dollar(5), Money.dollar(5))
        XCTAssertNotEqual(Money.dollar(5), Money.dollar(6))
        XCTAssertEqual(Money.franc(5), Money.franc(5))
        XCTAssertNotEqual(Money.franc(5), Money.franc(6))
        XCTAssertNotEqual(Money.dollar(5), Money.franc(5))
    }
    
    func testCurrency() {
        XCTAssertEqual("USD", Money.dollar(1).currency);
        XCTAssertEqual("CHF", Money.franc(1).currency);
    }
}
```

